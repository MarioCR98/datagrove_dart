import 'dart:collection';
import 'dart:typed_data';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:universal_html/html.dart';

import 'datagrove.dart';
import 'datagrove_flutter.dart';

typedef NamespaceTuple = DirectoryEntry;

class SearchController extends ChangeNotifier {}

// file widget should note the path and do a different transition
// if the path changes up, down, not at all.
class NamespaceController extends RangeController<NamespaceTuple> {
  Dgf dg;
  String path = "";
  List<NamespaceTuple> item = [];

  NamespaceController(this.dg) : super(NamespaceState("", [])) {
    _update();
  }

  orderByModified() {}
  orderByName() {}

  _update() async {
    if (path.isEmpty) return;
    List<DirectoryEntry> out = [];
    // await dg.localFileServer.readDir(path, out);
    // super.value = NamespaceState(path, out);
    notifyListeners();
  }

  @override
  RangeDiff diff(
      RangeState<NamespaceTuple> from, RangeState<NamespaceTuple> to) {
    return RangeDiff();
  }

  // do all kinds of folder type things!
}

class Wtree<K, V> {
  Wtree<K, V> slice() {
    return Wtree<K, V>();
  }
}

// should there be an asynchronous version of the tree?
// potentiall

class AsyncTree<K, V> {
  bool lengthKnown = false;
  int length = 0;
  Wtree<K, V> known;

  AsyncTree(this.known);
}

abstract class RangeController<T> extends ValueNotifier<RangeState<T>> {
  RangeController(super.value);
  RangeDiff diff(RangeState<T> from, RangeState<T> to);
}

// we need to be able to compute the difference between immutable states
abstract class RangeState<T> {
  int get length;
  T? operator [](int i);
}

// we don't need deleted, because we still have the old state.
class RangeDiff {
  static const up = -1;
  static const down = 1;
  static const same = 0;

  int direction = same;
  List<int> insert = [];
  List<int> delete = [];
  // this might not be enough? do we want to diff each value? maybe ok.
  List<int> updated = [];
}

// this should be generated
class Datum {}

// the ranges will be tuples, but the tuples can get reinterpreted as a type?
// for file system, how hard will this be?
// what if used a binary key, but allowed a dart object value?

class RangeSnapshot<Key, Value> {
  List<int> insert = [];
  List<int> delete = [];
  List<MapEntry<Key, Value>> deletedItem = [];
}

class RangeUpdate {}

// Datagrove is one big tree? but we only have pieces of it
// that piece is also just one big tree, then we hand our range controllers
//
class TreeManager {}

// The UiTree has to live in the flutter isolate, it represents a subset of
// of the offline and online trees.
// it tracks all the extent RangeControllers (dispose please!)
// ui tree can map Uint8List -> Cbor.
// we can't just change values either, we need to deltas to keep things straight
// each key could map to a set of delta steps?
// if we don't, aren't we always racing?
// say we notify listeners to a change, but the keyboard is also notifying
// the order of these things matters. our keyboard step may be invalidated
// onChange() { applyStep( )}

// core of Dgf, try to stick to dart here though

class Update {}

class TupleController {}

// textEditingController extends ValueNotifier<TextEditingValue>
//
// texteditingdelta is mostly for interacting with the keyboard
// here we need something that can interact with other users.
// textInputclient = something that receives TextInput from platform

// all of these things need to subscribe to something then break that
// subscription. but that's sort of what a controller does...

class SimpleRangeController<Key, Value> extends ChangeNotifier {
  // probably need our own map with nth, builder is going to need an index
  // animated list is going to need an index.
  // unclear if animated list needs a snapshot - can microtasks be launched
  // in the middle of a build? seems like it is only synchronous. but its complex;
  // what if you hand the tree to an asynchronous builder widget?
  final runway = Wtree<Key, Value>;
  bool lengthKnown = false;
  int length = 0;
  // this can be a closure when we create the range controller with all its particulars.
  Future<Error?> Function({int begin, int end})? filler;

  // can we stream deltas to it? does that make sense?
  void modify() {}

  SimpleRangeController();

  late Uint8List prefix;

  // scrolled into view?
  int start = 0;
  // total length of the virtual list

  RangeSnapshot<Key, Value> snapshot() {
    return RangeSnapshot();
  }

  @override
  dispose() {
    super.dispose();
  }

  //

  // getting items can be an async endeavor
  // but building is always synchronous
  // to manage this we need list tile that can have asynchronous contents
  // or a
  // Future<T> item(int i) async {
  //   return item_[0];
  // }
}

// every key has db_uuid, stream_varint, table_varint
// at least one index starts with these in this order
// probably should not be the primary key though?
// a more useful order is often db_uuid, table_varint, key, stream
// primary index should be the most used.
// consider a dictionary of db_uuid's instead of prefix compression?
// the number of discrete databases any one person uses is likely to be small.
// we generally want to refer to these by a friendly name
// when we look up the friendly name we could fetch the local index as well as
// the uuid.

class KeyValue {
  final Uint8List? key;
  final Uint8List? value;

  const KeyValue({this.key, this.value});

  // floats can't be sorted with memcmp without some work
  double at64(int i) => ByteData.sublistView(value!).getFloat64(i);
  void set64(int i, double x) {
    ByteData.sublistView(value!).setFloat64(i, x);
  }

  static KeyValue empty() {
    return KeyValue(key: Uint8List(0), value: Uint8List(0));
  }
  // T modify(List<int> index, List<dynamic> value) {
  //   return this as T;
  // }

  String at(int i) => "";
}

class Attribute {
  static const float64 = 1;
  static const int64 = 2;
  static const string = 3;
  static const byte = 4;
  static const fixedByte = 8;
  String name;
  int type;
  int offset;
  int length;
  Attribute(
      {required this.name,
      required this.type,
      required this.offset,
      this.length = 0});

  // writeKeyString(BytesBuilder b, String v) {
  //   switch
  //     b.add(utf8.encode(v));

  //   } else if (v is double) {

  //   }
  // }
  writeKey(BytesBuilder b, Uint8List tp) {
    switch (type) {
      case float64:
        ByteData byteData = ByteData(8);
        byteData.setUint64(0, readInt(tp), Endian.big);
        b.add(byteData.buffer.asUint8List());
        break;
      case int64:
        ByteData byteData = ByteData(8);
        byteData.setUint64(0, readInt(tp), Endian.big);
        b.add(byteData.buffer.asUint8List());
        break;
      case string:
        b.add(utf8.encode(readString(tp)));
        b.addByte(0);
        break;
      case byte:
        b.add(getBytes(tp));
        break;
      case fixedByte:
        b.add(tp.sublist(offset, offset + length));
        break;
    }
  }

  writeValue(Uint8List h, BytesBuilder heap, dynamic v) {}

  dynamic readValue(Uint8List v) {}

  String readString(Uint8List tp) {
    return "";
  }

  int readInt(Uint8List tp) {
    return 0;
  }

  Uint8List getBytes(Uint8List tp) {
    final bd = ByteData.sublistView(tp);
    // four byte offset into heap, 4 byte length
    bd.getUint32(offset, Endian.little);
    bd.getUint32(offset + 4, Endian.little);
    return Uint8List(0);
  }
}

// Change notifier is a flutter thing, so dart should use streams or callbacks?

// should this add or check for required fields?

class TableSchema<T> {
  final List<Attribute> attribute;
  List<int> primary;
  final List<List<int>> secondary; // negative is desc
  int headerSize = 0; // not counting heap. heap starts after

  TableSchema(
      {required this.attribute,
      required this.primary,
      required this.secondary});

  // we really only need the value here

  // range(DatagroveWorker dg, T begin, T end) {
  //   return RangeController<T>();
  // }

  // tuple, primary index, secondary index...
  List<Uint8List> make(Map<String, dynamic> change, {Uint8List? modify}) {
    final header = Uint8List(headerSize);
    final heap = BytesBuilder();
    List<dynamic>.filled(attribute.length, null);
    // this builds the header, and the heap
    for (final o in attribute) {
      var v = change[o.name];
      if (modify != null) {
        v ??= o.readValue(modify);
      }
      o.writeValue(header, heap, v);
    }
    final tp = (BytesBuilder()
          ..add(header)
          ..add(heap.toBytes()))
        .toBytes();

    // now we need to build the indices. The first one is the primary index
    // this needs to be appended to the secondary indices in a way that we can
    // easily recover it; we can append the length of the primary key component.
    //
    // build primary key
    final pkb = BytesBuilder();
    for (var o in primary) {
      attribute[o].writeKey(pkb, tp);
    }
    final pk = pkb.toBytes();

    final r = List<BytesBuilder>.filled(secondary.length, BytesBuilder());
    for (var i = 0; i < r.length; i++) {
      List<int> ky = secondary[i];
      for (int k in ky) {
        attribute[k].writeKey(r[i], tp);
      }
      r[i].add(pk);
      r[i].addByte(pk.length);
    }
    // append the primary key and its length to every secondary key.
    final rx =
        List<Uint8List>.generate(secondary.length, (i) => r[i + 1].toBytes());
    return <Uint8List>[tp, pk, ...rx];
  }
}

class ChatThread {}

/*

// the interior nodes are
// tableid | level | key



int sohash(Uint8List ln) {
  return equality.hash(ln);
}

int level(Uint8List ln) {
  int h = sohash(ln);
  var r = 0;
  while (h & 0xFF == 0) {
    h = h >> 8;
    r++;
  }
  return r;
}

class TableIndex {
  IndexNode? root;
  int length = 0;

  TableIndex(Db db, TableSchema sch) {}
  Future<List<Uint8List>> slice(int begin, int end) async {
    return [];
  }

  Uint8List? operator [](Uint8List key) {
    return null;
  }
}

class IndexNode {
  int level = 0;
  final pivot = SplayTreeMap<Uint8List, dynamic>();
}

class IndexLeaf {
  final tuple = SplayTreeMap<Uint8List, Uint8List>();
}


class Insert {
  Table table;
  File file;
  Uint8List key, value;
  Insert(this.table, this.file, this.key, this.value);
}

// tables represent pieces of all the datums that we subscribe to.
class Table {
  Db db;
  TableSchema schema;
  List<TableIndex> root = [];
  Table(this.db, this.schema) {}
  // we can keep the root page in memory for each table
  int get width => schema.column.length;

  Cursor cursor({start = 0}) {
    return Cursor(this, start: start);
  }
}
class Tx {
  var log = <int, LogStep>{};

  Db db;
  Tx(this.db);

  begin() {
    log.clear();
  }

  Future<bool> commit() async {
    return true;
  }

  Logfile create() {
    return Logfile(uuid()); // db.open(uuid());
  }

  // every tuple has a file
  replace(Uint8List key, List<int> attr, List<Uint8List> value) {}

  //remove(Table tbl, File f, Uint8List key) {}
}
*/
